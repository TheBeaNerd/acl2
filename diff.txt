diff --git a/axioms.lisp b/axioms.lisp
index 04746309f..ebf56d73d 100644
--- a/axioms.lisp
+++ b/axioms.lisp
@@ -20940,7 +20940,7 @@ evaluated.  See :DOC certify-book, in particular, the discussion about ``Step
 
 (defun default-backchain-limit (wrld flg)
   (declare (xargs :guard
-                  (and (member-eq flg '(:ts :rewrite))
+                  (and (member-eq flg '(:ts :rewrite :meta))
                        (plist-worldp wrld)
                        (alistp (table-alist 'acl2-defaults-table wrld))
                        (true-listp (assoc-eq :default-backchain-limit
diff --git a/defthm.lisp b/defthm.lisp
index cbf68cb28..e14423ca0 100644
--- a/defthm.lisp
+++ b/defthm.lisp
@@ -584,9 +584,10 @@
   (cond (backchain-limit-lst (cadr backchain-limit-lst))
         (t (let ((limit (default-backchain-limit wrld flg)))
              (and limit
-                  (make-list (length hyps)
-                             :initial-element
-                             limit))))))
+                  (cond ((eq flg :meta) limit)
+                        (t (make-list (length hyps)
+                                      :initial-element
+                                      limit))))))))
 
 (defun create-rewrite-rule (rune nume hyps equiv lhs rhs loop-stopper-lst
                                  backchain-limit-lst match-free-value wrld)
@@ -2979,12 +2980,15 @@
                    ctx ens wrld state))))
 
 (defun putprop-forward-chaining-rules-lst
-  (rune nume triggers hyps concls match-free wrld)
+  ;; DAG : :forward-chaining backchain-limit-lst support
+  (rune nume triggers backchain-limit-lst hyps concls match-free wrld)
   (cond ((null triggers)
          (put-match-free-value match-free rune wrld))
         (t (putprop-forward-chaining-rules-lst
             rune nume
             (cdr triggers)
+            ;; DAG : :forward-chaining backchain-limit-lst support
+            backchain-limit-lst 
             hyps concls match-free
             (putprop (ffn-symb (car triggers))
                      'forward-chaining-rules
@@ -2994,18 +2998,26 @@
                                  :trigger (car triggers)
                                  :hyps hyps
                                  :concls concls
+                                 ;; DAG : :forward-chaining backchain-limit-lst support
+                                 :backchain-limit-lst 
+                                 (rule-backchain-limit-lst
+                                  backchain-limit-lst 
+                                  hyps wrld :ts)
                                  :match-free match-free)
                            (getprop (ffn-symb (car triggers))
                                     'forward-chaining-rules nil
                                     'current-acl2-world wrld))
                      wrld)))))
 
-(defun add-forward-chaining-rule (rune nume trigger-terms term match-free wrld)
+;; DAG : :forward-chaining backchain-limit-lst support
+(defun add-forward-chaining-rule (rune nume trigger-terms backchain-limit-lst term match-free wrld)
   (mv-let
    (hyps concls)
    (destructure-forward-chaining-term term)
    (putprop-forward-chaining-rules-lst rune nume
                                        trigger-terms
+                                       ;; DAG : :forward-chaining backchain-limit-lst support
+                                       backchain-limit-lst 
                                        hyps concls
                                        (match-free-fc-value match-free
                                                             hyps concls
@@ -4388,7 +4400,12 @@
                             :rhs (if mfc-symbol 'extended nil)
                             :subclass 'meta
                             :heuristic-info nil
-                            :backchain-limit-lst backchain-limit)
+                            :backchain-limit-lst
+                            (rule-backchain-limit-lst
+                             backchain-limit
+                             nil ; hyps (ignored for :meta)
+                             wrld
+                             :meta))
                       (mark-attachment-disallowed
                        (if (eq hyp-fn t)
                            (list fn)
@@ -7378,18 +7395,35 @@
                                                (not (fquotep first-hyp))
                                                (eq (ffn-symb first-hyp) 'not))
                                           (fargn first-hyp 1)
-                                        first-hyp)))
+                                        first-hyp))
+                                     ;; DAG - if no trigger term or
+                                     ;; backchain limit list is
+                                     ;; provided we default to
+                                     ;; :backchain-limit-lst (0) which
+                                     ;; essentially requires that the
+                                     ;; first hyp (trigger term) be in
+                                     ;; the type-alist.
+                                     (backchain-limit-lst
+                                      (if (assoc-eq :BACKCHAIN-LIMIT-LST seen) nil
+                                        (list :BACKCHAIN-LIMIT-LST (list 0)))))
                                 (pprogn
+                                 ;; DAG - making the default behavior explicit.
                                  (observation ctx
                                               "The :TRIGGER-TERMS for the ~
                                                :FORWARD-CHAINING rule ~x0 will ~
-                                               consist of the list containing ~p1."
+                                               consist of the list containing ~p1 ~
+                                               and ~p2 must be true by simple type-set reasoning."
                                               name
-                                              (untranslate trigger-term nil wrld))
+                                              (untranslate trigger-term nil wrld)
+                                              (untranslate first-hyp nil wrld))
                                  (value (alist-to-keyword-alist
                                          seen
-                                         (list :TRIGGER-TERMS
-                                               (list trigger-term))))))))))
+                                         ;; DAG: add the default backchain-limit-lst
+                                         ;; if needed.
+                                         (append 
+                                          backchain-limit-lst
+                                          (list :TRIGGER-TERMS
+                                                (list trigger-term)))))))))))
             (t (value (alist-to-keyword-alist seen nil)))))
      ((eq token :TYPE-PRESCRIPTION)
       (cond ((not (assoc-eq :TYPED-TERM seen))
@@ -7735,6 +7769,8 @@
                      (cond
                       ((not (member-eq token
                                        '(:REWRITE :META :LINEAR
+                                                  ;; DAG - allow backchaining for forward-chaining rules, too.
+                                                  :FORWARD-CHAINING
                                                   :TYPE-PRESCRIPTION)))
                        (er soft ctx
                            "The rule-class ~@0 is not permitted to have a ~
@@ -8301,7 +8337,7 @@
             name
             (cadr (assoc-keyword :TYPED-TERM (cdr class)))
             term
-            (cadr (assoc-keyword :BACKCHAIN-LIMIT-LST (cdr class)))
+            (assoc-keyword :BACKCHAIN-LIMIT-LST (cdr class))
             ctx ens wrld state))
           (:DEFINITION
            (chk-acceptable-definition-rule
@@ -8484,8 +8520,7 @@
            (add-meta-rule rune nume
                           (cadr (assoc-keyword :TRIGGER-FNS (cdr class)))
                           term
-                          (cadr (assoc-keyword :BACKCHAIN-LIMIT-LST
-                                               (cdr class)))
+                          (assoc-keyword :BACKCHAIN-LIMIT-LST (cdr class))
                           wrld))
           (:CLAUSE-PROCESSOR
            (add-clause-processor-rule (base-symbol rune) term wrld))
@@ -8493,6 +8528,8 @@
            (add-forward-chaining-rule rune nume
                                       (cadr (assoc-keyword :TRIGGER-TERMS
                                                            (cdr class)))
+                                      ;; DAG : :forward-chaining backchain-limit-lst support
+                                      (assoc-keyword :BACKCHAIN-LIMIT-LST (cdr class))
                                       term
                                       (cadr (assoc-keyword :MATCH-FREE
                                                            (cdr class)))
@@ -8502,9 +8539,7 @@
                                        (cadr (assoc-keyword :TYPED-TERM
                                                             (cdr class)))
                                        term
-                                       (cadr (assoc-keyword
-                                              :BACKCHAIN-LIMIT-LST
-                                              (cdr class)))
+                                       (assoc-keyword :BACKCHAIN-LIMIT-LST (cdr class))
                                        ens wrld nil))
           (:DEFINITION
            (add-definition-rule rune nume
diff --git a/interface-raw.lisp b/interface-raw.lisp
index 6035d2c6d..1ce902fed 100644
--- a/interface-raw.lisp
+++ b/interface-raw.lisp
@@ -7901,7 +7901,7 @@ Missing functions (use *check-built-in-constants-debug* = t for verbose report):
                (ccl::*break-hook* nil)
                (*package* (find-package (current-package state)))
                (continue-p (and (find-restart 'continue)
-                                *acl2-time-limit*
+                                *acl2-time-limit-boundp*
                                 (not (eql *acl2-time-limit* 0)))))
            #+ccl ; for CCL revisions before 12090
            (declare (ignorable ccl::*break-hook*))
diff --git a/rewrite.lisp b/rewrite.lisp
index 22901a42d..bfe3d978d 100644
--- a/rewrite.lisp
+++ b/rewrite.lisp
@@ -4176,7 +4176,8 @@
          (t (mv term ttree)))))))
 
 (defun rewrite-solidify-rec (bound term type-alist obj geneqv ens wrld ttree
-                                   pot-lst pt)
+                                   ;; DAG - support for type-set backchain limits
+                                   pot-lst pt dag-backchain-limit)
   (declare (type (unsigned-byte 29) bound))
   (cond
    ((quotep term)
@@ -4292,14 +4293,19 @@
                 (declare (type (unsigned-byte 29) new-bound))
                 (rewrite-solidify-rec new-bound (fargn eterm 2) type-alist
                                       obj geneqv ens wrld ttree
-                                      pot-lst pt)))
+                                      ;; DAG - support for type-set backchain limits
+                                      pot-lst pt dag-backchain-limit)))
              (t (mv-let (ts ts-ttree)
 
 ; See the comment just after rewrite-solidify for some historical waffling.
 
                         (cond ((not (eq obj '?))
-                               (type-set term nil t type-alist
-                                         ens wrld nil pot-lst pt))
+                               (type-set-only term nil t type-alist
+                                              ens wrld nil pot-lst pt 
+                                              ;; DAG - use the -only interface to minimize type reasoning effort
+                                              ;; based on the objective
+                                              (objective-to-only obj)
+                                              dag-backchain-limit))
                               (t (assoc-type-alist term type-alist wrld)))
                         (if (null ts)
                             (mv term ttree)
@@ -4314,9 +4320,10 @@
   100)
 
 (defun rewrite-solidify (term type-alist obj geneqv ens wrld ttree
-                               pot-lst pt)
+                              ;; DAG - support for type-set backchain limits
+                               pot-lst pt dag-backchain-limit)
   (rewrite-solidify-rec *rewrite-equiv-solidify-iteration-bound* term
-                        type-alist obj geneqv ens wrld ttree pot-lst pt))
+                        type-alist obj geneqv ens wrld ttree pot-lst pt dag-backchain-limit))
 
 ; Comment on Historical Waffling over Calling Type-Set in Rewrite-Solidify
 ;
@@ -4405,7 +4412,8 @@
            (mv test ttree))
           ((equal left *t*)
            (mv-let (ts ts-ttree)
-             (type-set test ok-to-force nil type-alist ens wrld ttree nil nil)
+             ;; DAG - minimize type-set effort
+             (type-set-only test ok-to-force nil type-alist ens wrld ttree nil nil (ts-complement *ts-boolean*) (backchain-limit wrld :ts))
              (cond ((ts-subsetp ts *ts-boolean*)
                     (mv test ts-ttree))
                    (t (rewrite-if11 (mcons-term* 'if test left right)
@@ -11397,7 +11405,9 @@
                                        :current-enabled-structure)
                                wrld ttree
                                simplify-clause-pot-lst
-                               (access rewrite-constant rcnst :pt))))
+                               (access rewrite-constant rcnst :pt)
+                               ;; DAG - support for type-set backchain limits
+                               backchain-limit)))
            (t
             (let ((fn (ffn-symb term)))
               (cond
@@ -11546,7 +11556,9 @@
                                      :current-enabled-structure)
                              wrld ttree
                              simplify-clause-pot-lst
-                             (access rewrite-constant rcnst :pt))
+                             (access rewrite-constant rcnst :pt)
+                             ;; DAG - support for type-set backchain limits
+                             backchain-limit)
            (cond ((or (eq obj '?)
 
 ; Keep the next four conditions in sync with those in rewrite-with-lemmas.
@@ -12310,14 +12322,24 @@
                                   (forcep (and forcep1 force-flg)))
                              (mv-let
                               (knownp nilp nilp-ttree)
-                              (known-whether-nil
+                              ;; DAG - use the objective interface to minimize type reasoning.
+                              (known-whether-nil-obj
                                inst-hyp type-alist
                                (access rewrite-constant rcnst
                                        :current-enabled-structure)
                                force-flg
                                nil ; dwp
                                wrld
-                               ttree)
+                               ttree
+                               ;; DAG - we *could* be smarter here and
+                               ;; hit it again if obj="t" failed to
+                               ;; satisfy it .. that might help folks
+                               ;; who like to "force" type
+                               ;; prescription hyps as a matter of
+                               ;; course.
+                               (if forcep1 '? t) ;; objective
+                               backchain-limit
+                               )
                               (cond
                                (knownp
                                 (cond
@@ -13611,7 +13633,9 @@
                                        :current-enabled-structure)
                                wrld ttree
                                simplify-clause-pot-lst
-                               (access rewrite-constant rcnst :pt))))
+                               (access rewrite-constant rcnst :pt)
+                               ;; DAG - support for type-set backchain limits
+                               backchain-limit)))
            ((null rule) ; i.e., (flambdap fn)
             (cond
              ((and (not (recursive-fn-on-fnstackp fnstack))
@@ -13625,7 +13649,9 @@
                                          :current-enabled-structure)
                                  wrld ttree
                                  simplify-clause-pot-lst
-                                 (access rewrite-constant rcnst :pt))))
+                                 (access rewrite-constant rcnst :pt)
+                                 ;; DAG - support for type-set backchain limits
+                                 backchain-limit)))
              (t
               (sl-let
                (rewritten-body ttree1)
@@ -13657,7 +13683,9 @@
                                     wrld
                                     (accumulate-rw-cache t ttree1 ttree)
                                     simplify-clause-pot-lst
-                                    (access rewrite-constant rcnst :pt))))
+                                    (access rewrite-constant rcnst :pt)
+                                    ;; DAG - support for type-set backchain limits
+                                    backchain-limit)))
                 (t (mv step-limit rewritten-body ttree1)))))))
            (t
             (let* ((new-fnstack (cons (or recursivep fn) fnstack))
@@ -13707,7 +13735,9 @@
                                         wrld ttree
                                         simplify-clause-pot-lst
                                         (access rewrite-constant rcnst
-                                                :pt)))))
+                                                :pt)
+                                        ;; DAG - support for type-set backchain limits
+                                        backchain-limit))))
                    (t
                     (sl-let
                      (relieve-hyps-ans failure-reason unify-subst ttree1)
@@ -13777,7 +13807,9 @@
                                   wrld
                                   (accumulate-rw-cache t ttree1 ttree)
                                   simplify-clause-pot-lst
-                                  (access rewrite-constant rcnst :pt)))))
+                                  (access rewrite-constant rcnst :pt)
+                                  ;; DAG - support for type-set backchain limits
+                                  backchain-limit))))
                               (t (prog2$
                                   (brkpt2 t nil unify-subst gstack
                                           rewritten-body ttree1 rcnst state)
@@ -13914,7 +13946,9 @@
                                   (accumulate-rw-cache t ttree1 ttree)
                                   simplify-clause-pot-lst
                                   (access rewrite-constant rcnst
-                                          :pt))))))))
+                                          :pt)
+                                  ;; DAG - support for type-set backchain limits
+                                  backchain-limit)))))))
                         :conc
                         (access rewrite-rule rule :hyps)))
                       (t (prog2$
@@ -13930,7 +13964,9 @@
                                               t ttree1 ttree)
                                              simplify-clause-pot-lst
                                              (access rewrite-constant rcnst
-                                                     :pt)))))))))))
+                                                     :pt)
+                                             ;; DAG - support for type-set backchain limits
+                                             backchain-limit))))))))))
                 (t (prepend-step-limit
                     2
                     (rewrite-solidify term type-alist obj geneqv
@@ -13939,7 +13975,9 @@
                                       wrld ttree
                                       simplify-clause-pot-lst
                                       (access rewrite-constant rcnst
-                                              :pt))))))))))))
+                                              :pt)
+                                      ;; DAG - support for type-set backchain limits
+                                      backchain-limit)))))))))))
 
 (defun rewrite-with-lemmas (term ; &extra formals
                             rdepth step-limit
@@ -14084,7 +14122,9 @@
                                        wrld ttree
                                        simplify-clause-pot-lst
                                        (access rewrite-constant rcnst
-                                               :pt))))))))))))))))
+                                               :pt)
+                                       ;; DAG - support for type-set backchain limits
+                                       backchain-limit)))))))))))))))
 
 (defun rewrite-linear-term (term alist ; &extra formals
                                  rdepth step-limit
diff --git a/simplify.lisp b/simplify.lisp
index f7aec420d..225df36a2 100644
--- a/simplify.lisp
+++ b/simplify.lisp
@@ -715,7 +715,8 @@
 ; A forward chaining rule is
 
 (defrec forward-chaining-rule
-  ((rune . nume) trigger hyps concls . match-free) nil)
+  ;; DAG - add backchain-limit-lst support to :forward-chaining-rules
+  ((rune . nume) trigger (hyps . backchain-limit-lst) concls . match-free) nil)
 
 ; One of the main inefficiencies in our earlier forward chaining schemes
 ; was that if a rule began to fire but misfired because some hyp could
@@ -725,8 +726,12 @@
 ; attempt to fire a rule and resume it later.
 
 (defrec fc-activation
-  (inst-hyp (hyps . ttree)
-            unify-subst inst-trigger . rule) t)
+  ;; DAG - add backchain-limit support to activations .. a limit
+  ;; for the inst-hyp and a limit-list for the hyps.
+  ((inst-hyp . bc-limit) (hyps . ttree)
+            unify-subst 
+            backchain-limit-lst
+            inst-trigger . rule) t)
 
 ; Warning:  Despite the name, inst-hyp is not necessarily a term!
 ; See below.
@@ -837,7 +842,8 @@
 ; and ttree fields in variables and only put them back into the activation
 ; record when we decide to suspend it.  They may or may not have changed.
 
-(defun suspend-fc-activation (act inst-hyp hyps unify-subst ttree)
+;; DAG - maintain mapping between hyps and limits
+(defun suspend-fc-activation (act inst-hyp bc-limit hyps backchain-limit-lst unify-subst ttree)
 
 ; This function is equivalent to
 
@@ -872,27 +878,39 @@
 ; record.
 
   (cond ((equal unify-subst (access fc-activation act :unify-subst))
-
+         ;; DAG - we expect changes in backchain-limit-lst to be a subset
+         ;; of those in hyps.
          (cond ((and (equal hyps (access fc-activation act :hyps))
                      (equal ttree (access fc-activation act :ttree)))
                 (cond ((equal inst-hyp (access fc-activation act :inst-hyp))
 ; Case (a) -- 0 conses
                        act)
                       (t
+;; DAG - cons count may be off by one
 ; Case (c) -- 1 cons
                        (change fc-activation act
-                               :inst-hyp inst-hyp))))
+                               :inst-hyp inst-hyp
+                               ;; DAG - maintain mapping between hyps and limits
+                               :bc-limit bc-limit))))
                (t
+;; DAG - cons count may be off by one
 ; Case (b) -- 3 conses
+
+                ;; DAG - maintain mapping between hyps and limits
                 (change fc-activation act
                         :inst-hyp inst-hyp
+                        :bc-limit bc-limit
                         :hyps hyps
+                        :backchain-limit-lst backchain-limit-lst
                         :ttree ttree))))
         (t
+;; DAG - cons count may be off by two
 ; Otherwise -- 4 conses
          (change fc-activation act
                  :inst-hyp inst-hyp
+                 :bc-limit bc-limit
                  :hyps hyps
+                 :backchain-limit-lst backchain-limit-lst
                  :unify-subst unify-subst
                  :ttree ttree))))
 
@@ -1017,12 +1035,19 @@
 
                  (cond ((null unify-ans) nil)
                        (t (let ((rule-hyps
-                                 (access forward-chaining-rule rule :hyps)))
+                                 (access forward-chaining-rule rule :hyps))
+                                ;; DAG - use backchain-limit-lst from the :forward-chaining rule
+                                (backchain-limit-lst
+                                 (access forward-chaining-rule rule :backchain-limit-lst)))
                             (make fc-activation
                                   :inst-hyp *t*
+                                  ;; DAG - initial limit of nil
+                                  :bc-limit nil
                                   :hyps rule-hyps
                                   :ttree ttree
                                   :unify-subst unify-subst
+                                  ;; DAG - store backchain-limit-lst here
+                                  :backchain-limit-lst backchain-limit-lst
                                   :inst-trigger term
                                   :rule rule))))))))
 
@@ -2051,7 +2076,8 @@
 ; sites.  We call this ``filtering'' because we only move the objects that
 ; satisfy the criteria.
 
-(defun filter-satisfying-virtual-fc-activation (act0 inst-hyp hyps unify-subst ttree)
+;; DAG - maintain mapping between hyps and limits
+(defun filter-satisfying-virtual-fc-activation (act0 inst-hyp bc-limit hyps backchain-limit-lst unify-subst ttree)
 
 ; This is the function that adds an activation to the
 ; :blocked-false-satisfying-activations, aka site (1), of the current
@@ -2085,7 +2111,8 @@
                  (calls-alist (cdr (assoc-eq :FORWARD-CHAIN-CALLS data)))
                  (k (car (car calls-alist)))
                  (call-alist (cdr (car calls-alist)))
-                 (act (suspend-fc-activation act0 inst-hyp hyps
+                 ;; DAG - maintain mapping between hyps and limits
+                 (act (suspend-fc-activation act0 inst-hyp bc-limit hyps backchain-limit-lst
                                              unify-subst ttree)))
             (set-wormhole-data
              whs
@@ -2645,8 +2672,9 @@
 
 (mutual-recursion
 
+ ;; DAG - maintain mapping between hyps and limits
 (defun advance-fc-activation1
-  (act0 inst-hyp hyps unify-subst ttree                       ; key args
+  (act0 inst-hyp bc-limit hyps backchain-limit-lst unify-subst ttree                       ; key args
          fc-round type-alist ens force-flg wrld state oncep-override   ; contextual args
          suspensions fcd-lst)                                 ; answers
 
@@ -2698,7 +2726,8 @@
 ; if this hyp is to be forced or split upon we don't also suspend it.
 
                   (advance-fc-activation3
-                   act0 (cdr hyps) new-unify-subst-list new-ttree-list
+                   ;; DAG - maintain mapping between hyps and limits
+                   act0 (cdr hyps) (cdr backchain-limit-lst) new-unify-subst-list new-ttree-list
                    fc-round type-alist ens force-flg wrld state oncep-override
                    (if (or oncep1 (and forcer-fn force-flg))
                        suspensions
@@ -2708,7 +2737,10 @@
                                      forcer-fn
                                      (append new-keys-seen
                                              last-keys-seen))
+                              ;; DAG - maintain mapping between hyps and limits
+                              bc-limit
                               hyps
+                              backchain-limit-lst
                               unify-subst
                               ttree)
                              suspensions))
@@ -2738,7 +2770,8 @@
 ; Force-assumption always returns an unchanged force-flg which we just ignore.
                             (declare (ignore new-force-flg))
                             (advance-fc-activation2
-                             act0 (cdr hyps) unify-subst ttree
+                             ;; DAG - maintain mapping between hyps and limits
+                             act0 (cdr hyps) (cdr backchain-limit-lst) unify-subst ttree
                              fc-round type-alist ens force-flg wrld state
                              oncep-override
                              suspensions
@@ -2755,7 +2788,10 @@
                                     forcer-fn
                                     (append new-keys-seen
                                             last-keys-seen))
+                             ;; DAG - maintain mapping between hyps and limits
+                             bc-limit
                              hyps
+                             backchain-limit-lst
                              unify-subst
                              ttree)
                             suspensions)
@@ -2770,8 +2806,10 @@
 
     (mv-let
      (ts ttree1)
-     (type-set inst-hyp force-flg nil type-alist ens wrld nil
-                      nil nil)
+     ;; DAG - avoid working too hard to falsify hyp and use our
+     ;; backchain limit
+     (type-set-only inst-hyp force-flg nil type-alist ens wrld nil
+                         nil nil *ts-nil* bc-limit)
      (cond
       ((ts= ts *ts-nil*)
 
@@ -2780,7 +2818,8 @@
 
        (prog2$
         (filter-satisfying-virtual-fc-activation ; (FC Report)
-         act0 inst-hyp hyps unify-subst ttree)
+         ;; DAG - maintain mapping between hyps and limits
+         act0 inst-hyp bc-limit hyps  backchain-limit-lst unify-subst ttree)
         (mv suspensions
             fcd-lst)))
       ((ts-intersectp ts *ts-nil*)
@@ -2790,7 +2829,8 @@
 ; changes -- but we're in recursion, so who knows?
 ; Suspend-fc-activation will check if anything changed.
 
-       (mv (cons (suspend-fc-activation act0 inst-hyp hyps
+       ;; DAG - maintain mapping between hyps and limits
+       (mv (cons (suspend-fc-activation act0 inst-hyp bc-limit hyps backchain-limit-lst
                                         unify-subst ttree)
                  suspensions)
            fcd-lst))
@@ -2799,12 +2839,14 @@
 ; Finally!  We're past inst-hyp and begin to work our way down hyps.
 
        (advance-fc-activation2
-        act0 hyps unify-subst (cons-tag-trees ttree1 ttree)
+       ;; DAG - maintain mapping between hyps and limits
+        act0 hyps backchain-limit-lst unify-subst (cons-tag-trees ttree1 ttree)
         fc-round type-alist ens force-flg wrld state oncep-override
         suspensions fcd-lst)))))))
 
+;; DAG - maintain mapping between hyps and limits
 (defun advance-fc-activation2
-  (act0 hyps unify-subst ttree                               ; key args
+  (act0 hyps backchain-limit-lst unify-subst ttree                               ; key args
         fc-round type-alist ens force-flg wrld state oncep-override   ; contextual args
         suspensions fcd-lst)                                 ; answers
 
@@ -2836,7 +2878,10 @@
                          (or (eq (ffn-symb (car hyps)) 'force)
                              (eq (ffn-symb (car hyps)) 'case-split))))
            (forcer-fn (and forcep1 (ffn-symb (car hyps))))
-           (hyp (if forcep1 (fargn (car hyps) 1) (car hyps))))
+           ;; DAG - maintain mapping between hyps and limits
+           (hyp (if forcep1 (fargn (car hyps) 1) (car hyps)))
+           (bc-limit (car backchain-limit-lst))
+           )
       (cond
        ((free-varsp hyp unify-subst)
 
@@ -2849,7 +2894,10 @@
                  '(:FC-FREE-VARS FORCE . nil)
                  '(:FC-FREE-VARS CASE-SPLIT . nil))
              '(:FC-FREE-VARS nil . nil))
+         ;; DAG -- I *think* this is the right thing to do here to maintain our mapping ..
+         nil
          (cons hyp (cdr hyps))
+         backchain-limit-lst
          unify-subst
          ttree
          fc-round type-alist ens force-flg wrld state oncep-override
@@ -2863,8 +2911,10 @@
 
         (let ((inst-hyp (sublis-var unify-subst hyp)))
           (mv-let (ts ttree1)
-                  (type-set inst-hyp force-flg nil type-alist ens wrld nil
-                            nil nil)
+            ;; DAG - avoid working too hard to falsify hyp and use our
+            ;; bachain limit
+            (type-set-only inst-hyp force-flg nil type-alist ens wrld nil
+                           nil nil *ts-nil* bc-limit)
 
 ; Note that ttree1 is the ttree associated with the type-set computation
 ; and that it does not include ttree.  If we use the type-set
@@ -2876,7 +2926,8 @@
 ; abandon this activation.
                     (prog2$
                      (filter-satisfying-virtual-fc-activation ; (FC Report)
-                      act0 inst-hyp hyps unify-subst ttree)
+                      ;; DAG - maintain mapping between hyps and limits
+                      act0 inst-hyp bc-limit hyps backchain-limit-lst unify-subst ttree)
                      (mv suspensions
                          fcd-lst)))
                     ((ts-intersectp ts *ts-nil*)
@@ -2937,7 +2988,8 @@
 ; split upon.  So we did that and the result is in ttree.  Therefore, we
 ; just move on.
                              (advance-fc-activation2
-                              act0 (cdr hyps) unify-subst ttree
+                              ;; DAG - maintain mapping between hyps and limits
+                              act0 (cdr hyps) (cdr backchain-limit-lst) unify-subst ttree
                               fc-round type-alist ens force-flg wrld state oncep-override
                               suspensions fcd-lst))
                             (t
@@ -2951,7 +3003,10 @@
                              (mv (cons (suspend-fc-activation
                                         act0
                                         inst-hyp
+                                        ;; DAG - maintain mapping between hyps and limits
+                                        bc-limit
                                         (cdr hyps)
+                                        (cdr backchain-limit-lst)
                                         unify-subst
                                         ttree)
                                        suspensions)
@@ -2962,7 +3017,8 @@
 ; ttree2) plus the original one.
 
                           (advance-fc-activation2
-                           act0 (cdr hyps) unify-subst
+                           ;; DAG - maintain mapping between hyps and limits
+                           act0 (cdr hyps) (cdr backchain-limit-lst) unify-subst
                            (cons-tag-trees ttree2 ttree)
                            fc-round type-alist ens force-flg wrld state oncep-override
                            suspensions fcd-lst))
@@ -2973,7 +3029,8 @@
 
                           (prog2$
                            (filter-satisfying-virtual-fc-activation ; (FC Report)
-                            act0 inst-hyp hyps unify-subst ttree)
+                            ;; DAG - maintain mapping between hyps and limits
+                            act0 inst-hyp bc-limit hyps backchain-limit-lst unify-subst ttree)
                            (mv suspensions
                                fcd-lst))))))
                       (t
@@ -3005,7 +3062,8 @@
 ; Inst-hyp has been forced.  So just move on.
 
                           (advance-fc-activation2
-                           act0 (cdr hyps) unify-subst ttree
+                           ;; DAG - maintain mapping between hyps and limits
+                           act0 (cdr hyps) (cdr backchain-limit-lst) unify-subst ttree
                            fc-round type-alist ens force-flg wrld state oncep-override
                            suspensions fcd-lst))
                          (t
@@ -3019,7 +3077,10 @@
                           (mv (cons (suspend-fc-activation
                                      act0
                                      inst-hyp
+                                     ;; DAG - maintain mapping between hyps and limits
+                                     bc-limit
                                      (cdr hyps)
+                                     (cdr backchain-limit-lst)
                                      unify-subst
                                      ttree)
                                     suspensions)
@@ -3030,13 +3091,15 @@
 ; as we move on.
 
                      (advance-fc-activation2
-                      act0 (cdr hyps) unify-subst
+                      ;; DAG - maintain mapping between hyps and limits
+                      act0 (cdr hyps) (cdr backchain-limit-lst) unify-subst
                       (cons-tag-trees ttree1 ttree)
                       fc-round type-alist ens force-flg wrld state oncep-override
                       suspensions fcd-lst)))))))))))
 
+;; DAG - maintain mapping between hyps and limits
 (defun advance-fc-activation3
-  (act0 hyps unify-subst-lst ttree-lst                       ; key args
+  (act0 hyps backchain-limit-lst unify-subst-lst ttree-lst                       ; key args
         fc-round type-alist ens force-flg wrld state oncep-override   ; contextual args
         suspensions fcd-lst)                                 ; answers
   (cond ((endp unify-subst-lst)
@@ -3045,13 +3108,15 @@
          (mv-let (suspensions1 fcd-lst1)
                  (advance-fc-activation2
                   act0
-                  hyps (car unify-subst-lst) (car ttree-lst)
+                  ;; DAG - maintain mapping between hyps and limits
+                  hyps backchain-limit-lst (car unify-subst-lst) (car ttree-lst)
                   fc-round type-alist ens force-flg wrld state oncep-override
                   suspensions
                   fcd-lst)
                  (advance-fc-activation3
                   act0
-                  hyps (cdr unify-subst-lst) (cdr ttree-lst)
+                  ;; DAG - maintain mapping between hyps and limits
+                  hyps backchain-limit-lst (cdr unify-subst-lst) (cdr ttree-lst)
                   fc-round type-alist ens force-flg wrld state oncep-override
                   suspensions1 fcd-lst1)))))
 
@@ -3070,7 +3135,11 @@
    (advance-fc-activation1
     act
     (access fc-activation act :inst-hyp)
+    ;; DAG - slot for inst-hyp backchain limit
+    (access fc-activation act :bc-limit)
     (access fc-activation act :hyps)
+    ;; DAG - slot for hyps backchain limit list
+    (access fc-activation act :backchain-limit-lst)
     (access fc-activation act :unify-subst)
     (access fc-activation act :ttree)
     fc-round type-alist ens force-flg wrld state oncep-override
diff --git a/tau.lisp b/tau.lisp
index fdd76e514..a92566cff 100644
--- a/tau.lisp
+++ b/tau.lisp
@@ -11900,8 +11900,11 @@
    ((endp hyps) (mv t calist))
    (t (let* ((inst-hyp (subcor-var formals actuals (car hyps))))
         (mv-let (ts ttree)
-                (type-set inst-hyp nil nil type-alist
-                          ens wrld nil pot-lst nil)
+                (type-set-only inst-hyp nil nil type-alist
+                               ens wrld nil pot-lst nil 
+                               *ts-nil* ;; DAG - avoid working too hard to falsify hyp
+                               (backchain-limit wrld :ts) ;; backchain-limit
+                               )
                 (cond
                  ((or (tagged-objectsp 'assumption ttree)
                       (tagged-objectsp 'fc-derivation ttree))
diff --git a/type-set-b.lisp b/type-set-b.lisp
index 5c44b9ebb..e8264f752 100644
--- a/type-set-b.lisp
+++ b/type-set-b.lisp
@@ -6815,6 +6815,14 @@
          ((and ,not-flg (eq ,ignore :tta)) :fta)
          (t ,ignore)))
 
+(defmacro adjust-objective (not-flg obj)
+  
+; DAG - Adjust the objective based on the not-flg
+
+  `(let ((obj ,obj))
+     (if (or (not ,not-flg) (eq obj '?)) obj
+       (not obj))))
+
 ; To decide if backchaining has gone on long enough we use:
 
 (defun backchain-limit-reachedp1 (n ancestors)
@@ -6870,10 +6878,45 @@
 (defattach (oncep-tp oncep-tp-builtin)
   :skip-checks t)
 
+;; DAG - This macro allows us to pretend that nothing has changed with
+;; type-set-rec unless we specifically change it at the call site.
+(defmacro type-set-rec (x force-flg dwp type-alist ancestors ens w ttree
+                          pot-lst pt backchain-limit)
+  `(type-set-only-rec ,x ,force-flg ,dwp ,type-alist ,ancestors ,ens ,w ,ttree
+                      ,pot-lst ,pt ,backchain-limit ,*ts-unknown*))
+
+;; DAG - We use this to repair the type set returned from
+;; type-set-with-rules-only.  Since type-set-with-rules-only considers
+;; only rules that eliminate types in "only" we need to be
+;; conservative and say that any other type is possible.  NOTE: if
+;; only = *ts-unknown* then this has no effect.
+(defmacro conservative-type-spec (ts only)
+  `(ts-union ,ts (ts-complement ,only)))
+
+;; DAG - Express an objective as an 'only' typeset to minimize 
+;; the types of rules we will consider.
+(defmacro objective-to-only (obj)
+  ;; An objective is either t, nil or ?
+  `(if (eq ,obj '?) ,*ts-unknown*
+     (if ,obj ,*ts-nil* ,*ts-non-nil*)))
+
+;; DAG - Given that we may be ignoring one of the subsequent
+;; type-alists, is there any reasoning we can minimize when calling
+;; type-spec?
+(defmacro objective-from-ignore (ignore)
+  `(cond
+    ;; Only really try to falsify it
+    ((eq ,ignore :fta) nil)
+    ;; Only really try to verify it
+    ((eq ,ignore :tta) t)
+    (t                 '?)))
+
 (mutual-recursion
 
-(defun type-set-rec (x force-flg dwp type-alist ancestors ens w ttree
-                       pot-lst pt backchain-limit)
+;; DAG - This updated interface to type-set-rec allows us to limit the
+;; set of rules we are willing to apply during type-set reasoning.
+(defun type-set-only-rec (x force-flg dwp type-alist ancestors ens w ttree
+                                 pot-lst pt backchain-limit only)
 
 ; X is a term and type-alist is a type alist mapping terms to their type-sets
 ; (and some ttrees) and thus encoding the current assumptions.  In a break with
@@ -7082,7 +7125,8 @@
 ; We have to be careful to avoid forcing and use of the pot-lst.
 
      (mv-let (ts1 ttree1)
-             (type-set-rec (lambda-body (ffn-symb x))
+             ;; DAG - use the only interface to limit reasoning 
+             (type-set-only-rec (lambda-body (ffn-symb x))
                            nil ; avoid forcing in lambda-body context
                            nil ; dwp
                            (zip-variable-type-alist
@@ -7113,7 +7157,9 @@
 
                            nil
                            pt
-                           backchain-limit)
+                           backchain-limit
+                           ;; DAG - avoid duplicating effort
+                           (if ts0 (ts-intersection ts0 only) only))
              (type-set-finish x ts0 ttree0 ts1 ttree1 type-alist)))
 
 ;     ((flambda-applicationp x)
@@ -7157,14 +7203,24 @@
 ;      (type-set-finish x ts0 ttree0 *ts-unknown* ttree type-alist))
 
     ((eq (ffn-symb x) 'not)
-     (mv-let (ts1 ttree1)
-             (type-set-rec (fargn x 1) force-flg
-                           nil ; dwp
-                           type-alist ancestors
-                           ens w ttree pot-lst pt backchain-limit)
-             (mv-let (ts1 ttree1)
-                     (type-set-not ts1 ttree1 ttree)
-                     (type-set-finish x ts0 ttree0 ts1 ttree1 type-alist))))
+     ;;
+     ;; DAG - set up our 'only' mask for this dive into not. If we are
+     ;; looking for a specific boolean variable, then invert only to
+     ;; look for its negation.  Otherwise just allow everything.
+     ;; 
+     (let* ((nilonly (ts= only *ts-nil*))
+            (either (and (not nilonly) (ts-subsetp *ts-nil* only)))
+            (only   (if either *ts-unknown*
+                      (if nilonly *ts-non-nil* *ts-nil*))))
+       (mv-let (ts1 ttree1)
+         (type-set-only-rec (fargn x 1) force-flg
+                              nil ; dwp
+                              type-alist ancestors
+                              ens w ttree pot-lst pt backchain-limit
+                              only)
+         (mv-let (ts1 ttree1)
+           (type-set-not ts1 ttree1 ttree)
+           (type-set-finish x ts0 ttree0 ts1 ttree1 type-alist)))))
     (t
      (let* ((fn (ffn-symb x))
             (recog-tuple (most-recent-enabled-recog-tuple
@@ -7281,7 +7337,8 @@
                        x force-flg
                        dwp ; see comment in rewrite-atm about "use of dwp"
                        type-alist ancestors ens w
-                       *ts-unknown* ttree pot-lst pt backchain-limit)
+                       (ts-intersection ts only) ;; DAG don't duplicate effort
+                       ttree pot-lst pt backchain-limit)
                       (mv (ts-intersection ts ts2) ttree2))))))))
         ((eq fn 'if)
 
@@ -7309,7 +7366,9 @@
                                   ens
                                   w
                                   pot-lst pt nil
-                                  backchain-limit)
+                                  backchain-limit
+                                  '? ;; DAG -- we should recompute the objective from 'only'
+                                  )
 
 ; If must-be-true or must-be-false is set, then ttree1 explains the
 ; derivation of that result.  If neither is derived, then ttree1 is
@@ -7397,16 +7456,19 @@
 ; WARNING:  There is another call of type-set-with-rules above, in the
 ; recog-tuple case.  If you change this one, change that one!
 
-         (mv-let (ts1 ttree1)
+         ;; DAG - construct a real ts to work with below ..
+         (let ((ts1 (or ts0 *ts-unknown*)))
+           (mv-let (ts1 ttree1)
                  (type-set-with-rules
                   (getprop fn 'type-prescriptions nil 'current-acl2-world w)
                   x force-flg
                   dwp ; see comment in rewrite-atm about "use of dwp"
                   type-alist ancestors ens w
-                  *ts-unknown* ttree
+                  (ts-intersection ts1 only)  ;; DAG Don't duplicate effort
+                  ttree
                   pot-lst pt backchain-limit)
                  (type-set-finish x ts0 ttree0 ts1 ttree1
-                                  type-alist)))))))))
+                                  type-alist))))))))))
 
 (defun type-set-lst (x force-flg dwp type-alist ancestors ens w
                      pot-lst pt backchain-limit)
@@ -7842,7 +7904,8 @@
                         flg
                         (mv-let
                          (ts1 ttree1)
-                         (type-set-rec atm1 force-flg dwp type-alist
+                         ;; DAG - use the only interface to limit reasoning 
+                         (type-set-only-rec atm1 force-flg dwp type-alist
 
 ; We know ancestors is not t here, by the tests above.
 
@@ -7857,8 +7920,19 @@
                                        (new-backchain-limit
                                         (car backchain-limit-lst)
                                         backchain-limit
-                                        ancestors))
-                         (let ((ts (if not-flg
+                                        ancestors) 
+                                       ;; DAG - avoid working too hard
+                                       ;; to falsify hyps 
+                                       ;; 
+                                       ;; Note: we *could* be smarter
+                                       ;; here and hit it again if
+                                       ;; obj="t" failed to satisfy it
+                                       ;; .. that might help folks who
+                                       ;; like to "force" type
+                                       ;; prescription hyps as a
+                                       ;; matter of course.
+                                       (if forcep *ts-unknown* (if not-flg *ts-non-nil* *ts-nil*)))
+                         (let ((ts (if not-flg 
                                        (cond ((ts= ts1 *ts-nil*) *ts-t*)
                                              ((ts-intersectp ts1 *ts-nil*)
                                               *ts-boolean*)
@@ -8052,8 +8126,40 @@
                                 ttree
                                 pot-lst pt backchain-limit))))
 
-(defun type-set-with-rules (tp-lst term force-flg dwp type-alist ancestors ens
-                            w ts ttree pot-lst pt backchain-limit)
+;; DAG - This function is intended to act as a conservative interface
+;; for type-set-with-rules-only which, if not called initially with
+;; only = *ts-unknown*, is otherwise not conservative.
+(defun type-set-with-rules (tp-lst term force-flg dwp type-alist ancestors ens w
+                                   only
+                                   ttree pot-lst pt backchain-limit)
+  (mv-let
+    (ts1 ttree1)
+    ;; DAG - we have refactored this check to happend prior to the
+    ;; loop to minimize our effort in the loop.  The biggest
+    ;; difference is that we are using a different type-alist in this
+    ;; context .. (we don't return the type-alist so I'm not really
+    ;; sure what is going on with that)
+    (type-set-primitive term force-flg dwp type-alist ancestors ens w ttree
+                        pot-lst pt backchain-limit)
+    ;; We use this information to further reduce the size of our only target
+    (let ((only1 (ts-intersection ts1 only)))
+      (mv-let (tsres ttree2) (type-set-with-rules-only tp-lst term force-flg dwp type-alist ancestors ens w 
+                                                       only1
+                                                       ttree1 pot-lst pt backchain-limit)
+              ;; DAG - this restores to our type set any information
+              ;; that has not been obtained legitimately.
+              (let ((ts2 (conservative-type-spec tsres only1)))
+                (let ((ts3 (ts-intersection ts2 ts1)))
+                  ;; DAG - refactored from the original base case of type-set-with-rules
+                  (let ((ttree3 (if (ts= ts3 ts1) ttree1 ttree2)))
+                    (mv ts3 ttree3))))))))
+
+;; DAG - Note that this function is not sound unless it is called with
+;; only=*ts-unknown* or the return result is corrected using
+;; (conservative-type-spec tsres only).
+(defun type-set-with-rules-only (tp-lst term force-flg dwp type-alist ancestors ens w 
+                                       only 
+                                       ttree pot-lst pt backchain-limit)
 
 ; We try to apply each type-prescription in tp-lst, intersecting
 ; together all the type sets we get and accumulating all the ttrees.
@@ -8061,29 +8167,27 @@
 ; ignore its ttree.
 
   (cond
-   ((null tp-lst)
-    (mv-let
-     (ts1 ttree1)
-     (type-set-primitive term force-flg dwp type-alist ancestors ens w ttree
-                         pot-lst pt backchain-limit)
-     (let ((ts2 (ts-intersection ts1 ts)))
-       (mv ts2 (if (ts= ts2 ts) ttree ttree1)))))
+   ;; DAG - quit once the only mask is empty
+   ((or (null tp-lst) (ts= only *ts-empty*))
+    ;; DAG - why do we get to drop the "type-alist" that we have
+    ;; been accumulating all along?
+    (mv only ttree))
 
-   ((ts-subsetp ts
+   ((ts-subsetp only
                 (access type-prescription (car tp-lst) :basic-ts))
 
-; Our goal is to make the final type-set, ts, as small as possible by
-; intersecting it with the type-sets returned to the various rules.  If ts is
+; Our goal is to make the final type-set, only, as small as possible by
+; intersecting it with the type-sets returned to the various rules.  If only is
 ; already smaller than or equal to the :basic-ts of a rule, there is no point
 ; in trying that rule: the returned type-set will be at least as large as
 ; :basic-ts (it has the :vars types unioned into it) and then when we intersect
-; ts with it we'll just get ts back.  The original motivation for this
+; only with it we'll just get only back.  The original motivation for this
 ; short-cut was to prevent the waste of time caused by the
 ; pre-guard-verification type-prescription if the post-guard-verification rule
 ; is present.
 
-    (type-set-with-rules (cdr tp-lst)
-                         term force-flg dwp type-alist ancestors ens w ts ttree
+    (type-set-with-rules-only (cdr tp-lst)
+                         term force-flg dwp type-alist ancestors ens w only ttree
                          pot-lst pt backchain-limit))
    (t
      (mv-let
@@ -8091,15 +8195,15 @@
        (type-set-with-rule (car tp-lst)
                            term force-flg dwp type-alist ancestors ens w ttree
                            pot-lst pt backchain-limit)
-       (let ((ts2 (ts-intersection ts1 ts)))
-         (type-set-with-rules (cdr tp-lst)
-                              term force-flg dwp type-alist1 ancestors ens w
-                              ts2
-                              (if (and (ts= ts2 ts)
-                                       (equal type-alist type-alist1))
-                                  ttree
-                                  ttree1)
-                              pot-lst pt backchain-limit))))))
+       (let ((only2 (ts-intersection ts1 only)))
+         (type-set-with-rules-only (cdr tp-lst)
+                                   term force-flg dwp type-alist1 ancestors ens w
+                                   only2
+                                   (if (and (ts= only2 only)
+                                            (equal type-alist type-alist1))
+                                       ttree
+                                     ttree1)
+                                   pot-lst pt backchain-limit))))))
 
 ;; RAG - I added an entry for floor1, which is the only primitive
 ;; non-recognizer function we added for the reals.  [Ruben added entries for
@@ -8642,9 +8746,10 @@
 ;; RAG - In this function, I relaxed the tests for rational to include
 ;; realp as well.
 
+;; DAG - add an objective flag to limit type reasoning
 (defun assume-true-false-if (not-flg x xttree force-flg dwp
                                      type-alist ancestors ens w
-                                     pot-lst pt backchain-limit)
+                                     pot-lst pt backchain-limit obj)
 
 ; X is an IF-expression we have been asked to assume-true-false.  We
 ; return the standard tuple through the standard calls to mv-atf.
@@ -8661,13 +8766,30 @@
         (true-branch (fargn x 2))
         (false-branch (fargn x 3)))
 
+  ;; DAG - if the form is a logical 'and' or 'or' then evaluate the 
+  ;; test with the given objective
+  (let* ((boolean-objective (not (eq obj '?)))
+         (andlike-term      (and boolean-objective (or (equal true-branch *t*)
+                                                       (equal false-branch *nil*))))
+         ;; DAG - Because (or x y) appears to normalize into (if x x
+         ;; y) we need to do this to allow or's pushed by forward
+         ;; chaining rules to benefit from our optimizations.  Perhaps
+         ;; if we normalized boolean or's into (if x t y) we could
+         ;; drop this test ..
+         (equal-test-true-branch nil) #+joe(and boolean-objective
+                                                (not andlike-term)
+                                                (equal test true-branch))
+         (testobj (if (or andlike-term equal-test-true-branch) obj
+                    '?)))
+
 ; We start by recurring on the test.
 
     (mv-let (test-mbt test-mbf test-tta test-fta test-ttree)
             (assume-true-false-rec test xttree force-flg
                                    dwp type-alist ancestors ens w
                                    pot-lst pt nil
-                                   backchain-limit)
+                                   ;; DAG - pass along the test objective
+                                   backchain-limit testobj)
 
 ; In the first two branches, we know that test must be true or that test
 ; must be false.  We recur on the true branch or the false branch
@@ -8681,14 +8803,16 @@
                       (assume-true-false-rec true-branch test-ttree force-flg
                                              dwp test-tta ancestors ens w
                                              pot-lst pt nil
-                                             backchain-limit)
+                                             ;; DAG - pass along the objective
+                                             backchain-limit obj)
                       (mv-atf not-flg mbt mbf tta fta ttree nil)))
              (test-mbf
               (mv-let (mbt mbf tta fta ttree)
-                      (assume-true-false-rec false-branch test-ttree force-flg
-                                             dwp test-fta ancestors ens w
-                                             pot-lst pt nil
-                                             backchain-limit)
+                (assume-true-false-rec false-branch test-ttree force-flg
+                                       dwp test-fta ancestors ens w
+                                       pot-lst pt nil
+                                       ;; DAG - pass along the objective
+                                       backchain-limit obj)
                       (mv-atf not-flg mbt mbf tta fta ttree nil)))
 
              (t
@@ -8701,14 +8825,20 @@
 
               (mv-let
                (tb-mbt tb-mbf tb-tta tb-fta tb-ttree)
-               (assume-true-false-rec true-branch xttree force-flg
-                                      dwp test-tta ancestors ens w
-                                      pot-lst pt nil backchain-limit)
+               ;; DAG - I'm just not sure how common this case is
+               ;; .. and we don't want to waste time doing equality
+               ;; checks of terms if it rarely happens ..
+               (if equal-test-true-branch (mv test-mbt test-mbf test-tta test-fta test-ttree)
+                 (assume-true-false-rec true-branch xttree force-flg
+                                        dwp test-tta ancestors ens w
+                                        ;; DAG - pass along the objective
+                                        pot-lst pt nil backchain-limit obj))
                (mv-let
                 (fb-mbt fb-mbf fb-tta fb-fta fb-ttree)
                 (assume-true-false-rec false-branch xttree force-flg
                                        dwp test-fta ancestors ens w
-                                       pot-lst pt nil backchain-limit)
+                                       ;; DAG - pass along the objective
+                                       pot-lst pt nil backchain-limit obj)
                 (cond
 
                  ((and tb-mbf fb-mbf)
@@ -8940,10 +9070,15 @@
                                           type-alist)
                                          (extend-type-alist-simple
                                           x *ts-nil* xttree type-alist)
-                                         nil nil)))))))))))))
+                                         nil nil))))))))))))))
 
+;; DAG - extend the signature to include and objective flag.  Note
+;; that the objective is similar to 'ignore0' but .. not exactly the
+;; same.  We tried using ignore0 .. but at some point, as you begin to
+;; thread it deeper into other functions, you begin to lie about the
+;; fact that you are going to 'ignore' one of the outputs.
 (defun assume-true-false-rec (x xttree force-flg dwp type-alist ancestors ens w
-                                pot-lst pt ignore0 backchain-limit)
+                                pot-lst pt ignore0 backchain-limit obj)
 
 ; We assume x both true and false, extending type-alist as appropriate.
 ; Xttree is the ttree with which we are to tag all the entries added to
@@ -9035,21 +9170,25 @@
     ((variablep x)
      (assume-true-false1
       xnot-flg x xttree force-flg dwp type-alist ancestors ens w
-      pot-lst pt backchain-limit))
+      ;; DAG - pass along an adjusted objective flag
+      pot-lst pt backchain-limit (adjust-objective xnot-flg obj)))
     ((fquotep x)
      (if (equal x *nil*)
          (mv-atf xnot-flg nil t nil type-alist nil xttree)
          (mv-atf xnot-flg t nil type-alist nil nil xttree)))
     ((flambda-applicationp x)
      (assume-true-false1 xnot-flg x xttree
-                         force-flg dwp type-alist ancestors ens w
-                         pot-lst pt backchain-limit))
+                                force-flg dwp type-alist ancestors ens w
+                                ;; DAG - pass along an adjusted objective flag
+                                pot-lst pt backchain-limit (adjust-objective xnot-flg obj)))
     (t
      (let ((recog-tuple
             (most-recent-enabled-recog-tuple (ffn-symb x)
                                              (global-val 'recognizer-alist w)
                                              ens))
-           (ignore (adjust-ignore-for-atf xnot-flg ignore0)))
+           (ignore (adjust-ignore-for-atf xnot-flg ignore0))
+           ;; DAG - compute an adjusted objective flag
+           (obj1    (adjust-objective xnot-flg obj)))
        (cond
         (recog-tuple
 
@@ -9225,7 +9364,8 @@
                        (fargs x)
                        (body (ffn-symb x) t w))
            xttree force-flg dwp type-alist ancestors ens w
-           pot-lst pt ignore backchain-limit)
+           ;; DAG - pass along the adjusted objective flag
+           pot-lst pt ignore backchain-limit obj1)
           (if xnot-flg
               (mv mbf mbt fta tta ttree)
               (mv mbt mbf tta fta ttree))))
@@ -9862,7 +10002,8 @@
 ; the corresponding components of x.  Q.E.D.
 
                       xttree force-flg dwp type-alist ancestors ens w
-                      pot-lst pt backchain-limit)
+                      ;; DAG - pass along an adjusted objective flag
+                      pot-lst pt backchain-limit (adjust-objective xnot-flg obj))
 
 ; Inefficiency: It is somewhat troubling that we are holding ts1 and
 ; ts2 in our hands while invoking assume-true-false1 on (< arg1 arg2),
@@ -10023,7 +10164,8 @@
          (mv-let (mbt mbf tta fta ttree)
                  (assume-true-false1
                   xnot-flg x xttree force-flg dwp type-alist ancestors ens w
-                  pot-lst pt backchain-limit)
+                  ;; DAG - pass along an adjusted objective flag
+                  pot-lst pt backchain-limit (adjust-objective xnot-flg obj))
                  (cond ((or mbt mbf)
                         (mv mbt mbf tta fta ttree))
                        (t (let ((tta (if xnot-flg fta tta))
@@ -10032,21 +10174,27 @@
                                     (assume-true-false-rec
                                      (fargn x 1)
                                      xttree force-flg dwp tta ancestors ens w
-                                     pot-lst pt :fta backchain-limit)
+                                     ;; DAG - pass along an unknown objective flag
+                                     pot-lst pt :fta backchain-limit '?)
                                     (declare (ignore mbt1 fta1))
                                     (mv-atf xnot-flg mbt mbf tta1 fta
                                             ttree nil)))))))
         ((eq (ffn-symb x) 'IF)
          (assume-true-false-if xnot-flg x xttree force-flg dwp
                                type-alist ancestors ens w
-                               pot-lst pt backchain-limit))
+                               ;; DAG - pass along an adjusted objective flag
+                               pot-lst pt backchain-limit (adjust-objective xnot-flg obj)))
         (t (assume-true-false1 xnot-flg x xttree
-                               force-flg dwp type-alist ancestors ens
-                               w
-                               pot-lst pt backchain-limit))))))))
-
+                                      force-flg dwp type-alist ancestors ens
+                                      w
+                                      ;; DAG - pass along an adjusted objective flag
+                                      pot-lst pt backchain-limit (adjust-objective xnot-flg obj)))))))))
+
+;;
+;; DAG - passing assume-true-false1 the objective flag from assume-true-false
+;;
 (defun assume-true-false1 (not-flg x xttree force-flg dwp type-alist ancestors
-                                   ens w pot-lst pt backchain-limit)
+                                   ens w pot-lst pt backchain-limit obj)
 
 ; Roughly speaking, this is the simple assume-true-false, which just
 ; computes the type-set of x and announces that x must be t, must be
@@ -10062,10 +10210,11 @@
 ; type-alists.
 
   (mv-let (ts ttree)
-          (type-set-rec x force-flg
-                        dwp
-                        type-alist ancestors ens w nil
-                        pot-lst pt backchain-limit)
+          (type-set-only-rec x force-flg
+                             dwp
+                             type-alist ancestors ens w nil
+                             ;; DAG - use the objective flag to compute an only type set
+                             pot-lst pt backchain-limit (objective-to-only obj))
 
 ; If we can decide x on the basis of ts, do so and report use of ttree.
 ; Xttree will be put in by mv-atf.
@@ -10196,22 +10345,34 @@
 
 )
 
-(defun type-set (x force-flg dwp type-alist ens w ttree pot-lst pt)
-
+;; DAG - This interface to type-set allows us to limit the set of rules
+;; we apply during type-set reasoning to to restrict backchaining
+(defun type-set-only (x force-flg dwp type-alist ens w ttree pot-lst pt only backchain-limit)
+  
 ; See type-set-rec.
 
-  (type-set-rec x force-flg dwp type-alist
-                nil ; ancestors
-                ens w ttree
-                pot-lst pt
-                (backchain-limit w :ts)))
+  (type-set-only-rec x force-flg dwp type-alist
+                     nil ; ancestors
+                     ens w ttree
+                     pot-lst pt
+                     ;; DAG - Or perhaps the minimum of backchain-limit and (backchain-limit w :ts) ?
+                     backchain-limit only))
+
+;; DAG - This macro allows us to pretend that nothing has changed with
+;; type-set unless we specifically change it at the call site.  Note
+;; that we are using a conservative value for only.
+(defmacro type-set (x force-flg dwp type-alist ens w ttree pot-lst pt)
+  `(let ((w ,w))
+     (type-set-only ,x ,force-flg ,dwp ,type-alist ,ens w ,ttree ,pot-lst ,pt ,*ts-unknown* (backchain-limit w :ts))))
 
 (defun assume-true-false (x xttree force-flg dwp type-alist ens w pot-lst pt
                             ignore0)
   (assume-true-false-rec x xttree force-flg dwp type-alist
                          nil ; ancestors
                          ens w pot-lst pt ignore0
-                         (backchain-limit w :ts)))
+                         (backchain-limit w :ts)
+                         ;; DAG - use the ignore flag to compute an objective
+                         (objective-from-ignore ignore0)))
 
 (defun ok-to-force-ens (ens)
   (and (enabled-numep *force-xnume* ens)
@@ -10837,7 +10998,13 @@
                  type-alist0 ens wrld
                  *type-alist-equality-loop-max-depth*))))))
 
-(defun known-whether-nil (x type-alist ens force-flg dwp wrld ttree)
+;; DAG - This macro allows us to pretend that nothing has changed with
+;; known-whether-nil nless we specifically change it at the call site.
+(defmacro known-whether-nil (x type-alist ens force-flg dwp wrld ttree)
+  `(known-whether-nil-obj ,x ,type-alist ,ens ,force-flg ,dwp ,wrld ,ttree '? (backchain-limit ,wrld :ts)))
+
+;; DAG - Add an objective flag and backchain limit to restrict type reasoning
+(defun known-whether-nil-obj (x type-alist ens force-flg dwp wrld ttree obj backchain-limit)
 
 ; This function determines whether we know, from type-set reasoning,
 ; whether x is nil or not.  It returns three values.  The first is the
@@ -10862,7 +11029,8 @@
   (cond ((quotep x)
          (mv t (equal x *nil*) ttree))
         (t (mv-let (ts ttree)
-                   (type-set x force-flg dwp type-alist ens wrld ttree nil nil)
+                   ;; DAG - use the objective flag to compute an only type set
+                   (type-set-only x force-flg dwp type-alist ens wrld ttree nil nil (objective-to-only obj) backchain-limit)
                    (cond ((ts= ts *ts-nil*)
                           (mv t t ttree))
                          ((ts-intersectp ts *ts-nil*)
@@ -11167,10 +11335,13 @@
                                     (iff-flg (mv t1 ttree))
                                     (t
                                      (mv-let (ts1 ttree1)
-                                             (type-set
+                                             (type-set-only
                                               t1 ; see note above on force-flg
                                               nil nil type-alist ens wrld nil
-                                              nil nil)
+                                              nil nil
+                                              ;; DAG - restrict type reasoning
+                                              (ts-complement *ts-boolean*)
+                                              (backchain-limit wrld :ts))
                                              (cond
                                               ((ts-subsetp ts1 *ts-boolean*)
                                                (mv t1 (cons-tag-trees ttree1
@@ -11338,8 +11509,11 @@
                              (iff-flg (mv t1 ttree))
                              (t (mv-let
                                  (ts1 ttree1)
-                                 (type-set t1 nil nil type-alist ens wrld nil
-                                           nil nil)
+                                 (type-set-only t1 nil nil type-alist ens wrld nil
+                                           nil nil
+                                           ;; DAG -- restrict type reasoning
+                                           (ts-complement *ts-boolean*)
+                                           (backchain-limit wrld :ts))
                                  (cond
                                   ((ts-subsetp ts1 *ts-boolean*)
                                    (mv t1 (cons-tag-trees ttree1 ttree)))
